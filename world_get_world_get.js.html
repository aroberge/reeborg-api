<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Advanced World Creation Source: world_get/world_get.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.reeborg.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Advanced World Creation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="RUR.html">RUR</a></li>
				</ul>
			</li>
			
		</ul>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: world_get/world_get.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/* Obtain specific information about the world, either at a given
   position, or for the world in general.
*/

require("./../rur.js");
require("./../programming_api/exceptions.js");
require("./../default_tiles/tiles.js");
require("./../dialogs/create.js");
require("./../listeners/canvas.js");
require("./../utils/supplant.js");
require("./../world_api/things.js");

RUR.world_get = {};

RUR.world_get.tile_at_position = function (x, y) { // TODO: still needed or move elswhere?
    "use strict";
    var coords = x + "," + y;
    if (RUR.get_current_world().tiles === undefined) return false;
    if (RUR.get_current_world().tiles[coords] === undefined) return false;
    return RUR.THINGS[RUR.get_current_world().tiles[coords]];
};


RUR.world_get.object_at_robot_position = function (robot, obj) { // TODO: still needed or move elswhere?
    return object_of_type_here(robot, obj, RUR.get_current_world().objects);
};


function object_of_type_here (robot, obj, object_type) {
    // object_type == RUR.get_current_world().objects or RUR.get_current_world().decorative_objects
    var obj_here, obj_type, all_objects;
    var coords = robot.x + "," + robot.y;

    if (object_type === undefined ||
        object_type[coords] === undefined) {
        return [];
    }

    obj_here =  object_type[coords];
    all_objects = [];

    for (obj_type in obj_here) {
        if (obj_here.hasOwnProperty(obj_type)) {
            if (obj !== undefined &amp;&amp; obj_type == RUR.translate_to_english(obj)) {
                return [RUR.translate(obj_type)];
            }
            all_objects.push(RUR.translate(obj_type));
        }
    }

    if (obj !== undefined) {
        return [];
    } else if (all_objects.length === 0){
        return [];
    } else {
        return all_objects;
    }
}

/** @function world_map
 * @memberof RUR
 * @instance
 *
 * @desc Returns a JSON object representing the world and all
 * its content.  For Python, use `SatelliteInfo.world_map` instead.
 *
 */

RUR.world_map = function () {
    "use strict"
    var world, to_remove, i;
    // clone the world so as not to modify the original
    world = JSON.parse(JSON.stringify(RUR.get_current_world()));
    to_remove = ["description", "editor", "library", "pre", "post", "onload"];
    for (i=0; i &lt; to_remove.length; i++) {
        if (world[to_remove[i]] !== undefined) {
            delete world[to_remove[i]];
        }
    }
    return world;
};

/** @function print_world_map
 * @memberof RUR
 * @instance
 *
 * @desc Prints a formatted version of the world map.
 * For Python, use `SatelliteInfo.print_world_map()` instead.
 *
 */

RUR.print_world_map = function () {
    RUR.output.write(JSON.stringify(RUR.world_map(), null, 2), "\n");
};


// Used by SatelliteInfo class in Python
RUR._world_map = function () {
    return JSON.stringify(RUR.world_map(), null, 2);
};

RUR.world_get.world_info = function (no_grid) {
    "use strict";
    // shows the information about a given grid position
    // when the user clicks on the canvas at that grid position.
    var position, tile, obj, information, x, y, coords, obj_here, obj_type, goals;
    var topic, no_object, r, robot, robots;
    var tiles, tilename, fence_noted = false;
    var description, insertion, to_replace;


    information = "&lt;div class='automatic-description'>";

    if (RUR.get_current_world().description) {
        description = RUR.get_current_world().description;
        if (RUR.get_current_world().pre) {
            insertion = "&lt;pre class='world_info_source'>" + RUR.get_current_world().pre + "&lt;/pre>";
            to_replace = "INSERT_PRE";
            description = description.replace(to_replace, insertion);
        }
        if (RUR.get_current_world().editor) {
            insertion = "&lt;pre class='world_info_source'>" + RUR.get_current_world().editor + "&lt;/pre>";
            to_replace = "INSERT_EDITOR";
            description = description.replace(to_replace, insertion);
        }
        if (RUR.get_current_world().library) {
            insertion = "&lt;pre class='world_info_source'>" + RUR.get_current_world().library + "&lt;/pre>";
            to_replace = "INSERT_LIBRARY";
            description = description.replace(to_replace, insertion);
        }
        if (RUR.get_current_world().post) {
            insertion = "&lt;pre class='world_info_source'>" + RUR.get_current_world().post + "&lt;/pre>";
            to_replace = "INSERT_POST";
            description = description.replace(to_replace, insertion);
        }
        if (RUR.get_current_world().onload) {
            if (RUR.CURRENT_WORLD.onload[0]=="#") {
                RUR.state.onload_programming_language = "python";
            } else {
                RUR.state.onload_programming_language = "javascript";
            }
            insertion = "&lt;pre class='world_info_onload'>" + RUR.get_current_world().onload + "&lt;/pre>";
            to_replace = "INSERT_ONLOAD";
            description = description.replace(to_replace, insertion);
        }
        information +="&lt;h2>" + RUR.translate("Description") + "&lt;/h2>" + description + "&lt;/div>";
    }

    if (!no_grid) {
        position = RUR.calculate_grid_position();
        x = position[0];
        y = position[1];
        coords = x + "," + y;
        if (!isNaN(x)){
            information += "&lt;br>x,y = " + coords + "&lt;br>&lt;br>";
        }
    }

    try {
        tile = RUR.world_get.tile_at_position(x, y);
    } catch (e) {
        tile = false;
    }
    topic = true;
    if (tile){
        if (RUR.translate(tile.info)) {
            if (topic){
                topic = false;
                information += "&lt;b>" + RUR.translate("Special information about this location:") + "&lt;/b>";
            }
            information += "&lt;br>" + RUR.translate(tile.info);
        }
    }

    try {
        tiles = RUR.get_obstacles(x, y);
    } catch (e) {
        tiles = false;
    }
    if (tiles) {
        for (tilename of tiles) {
            tile = RUR.THINGS[tilename];
            if (RUR.translate(tile.info)){
                if (topic){
                    topic = false;
                    information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("Special information about this location:") + "&lt;/b>";
                }
                if (tile.name == "fence") {
                    if (!fence_noted) {
                        fence_noted = true;
                        information += "&lt;br>" + RUR.translate(tile.info);
                    }
                } else {
                    information +=  "&lt;br>" + RUR.translate(tile.info);
                }
            }
        }
    }

    obj = RUR.get_current_world().objects;
    topic = true;
    if (obj !== undefined &amp;&amp; obj[coords] !== undefined){
        obj_here = obj[coords];
        for (obj_type in obj_here) {
            if (obj_here.hasOwnProperty(obj_type)) {
                if (topic){
                    topic = false;
                    information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("Objects found here:") + "&lt;/b>";
                }
                information += "&lt;br>" + RUR.translate(obj_type) + ":" + obj_here[obj_type];
                information += " " + RUR.translate(RUR._get_property(obj_type, "info"));
            }
        }
    }

    goals = RUR.get_current_world().goal;
    if (goals !== undefined){
        obj = goals.objects;
        topic = true;
        if (obj !== undefined &amp;&amp; obj[coords] !== undefined){
            obj_here = obj[coords];
            for (obj_type in obj_here) {
                if (obj_here.hasOwnProperty(obj_type)) {
                    if (topic){
                        topic = false;
                        information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("Goal to achieve:") + "&lt;/b>";
                    }
                   information += "&lt;br>" + RUR.translate(obj_type) + ":" + obj_here[obj_type];
                }
            }
        }
    }


    if (goals !== undefined){
        if (goals.walls !== undefined &amp;&amp; coords) {
            if (goals.walls[coords] !== undefined){
                if (goals.walls[coords].indexOf("east") != -1) {
                    information += "&lt;br>" + RUR.translate("A wall must be built east of this location.");
                }
                if (goals.walls[coords].indexOf("north") != -1) {
                    information += "&lt;br>" + RUR.translate("A wall must be built north of this location.");
                }
            }
            x -= 1;
            coords = x + "," + y;
            if (goals.walls[coords] !== undefined){
                if (goals.walls[coords].indexOf("east") != -1) {
                    information += "&lt;br>" + RUR.translate("A wall must be built west of this location.");
                }
            }
            x += 1;
            y -= 1;
            coords = x + "," + y;
            if (goals.walls[coords] !== undefined){
                if (goals.walls[coords].indexOf("north") != -1) {
                    information += "&lt;br>" + RUR.translate("A wall must be built south of this location.");
                }
            }
            y += 1;
            coords = x + "," + y;
        }
    }

    robots = RUR.get_current_world().robots;
    if (robots !== undefined &amp;&amp; robots.length !== undefined){
        for (r=0; r&lt;robots.length; r++){
            robot = robots[r];
            x = robot.x;
            y = robot.y;
            if (robot.possible_initial_positions !== undefined &amp;&amp; robot.possible_initial_positions.length > 1){
                x = RUR.translate("random location");
                y = '';
            }
            no_object = true;
            for (obj in robot.objects){
                if (robot.objects.hasOwnProperty(obj)) {
                    if (no_object) {
                        no_object = false;
                        information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("A robot located here carries:").supplant({x:x, y:y}) + "&lt;/b>";
                    }
                    information += "&lt;br>" + RUR.translate(obj) + ":" + robot.objects[obj];
                }
            }
            if (no_object){
                information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("A robot located here carries no objects.").supplant({x:x, y:y}) + "&lt;/b>";
            }
        }
    }


    goals = RUR.get_current_world().goal;
    if (goals !== undefined &amp;&amp;
         (goals.possible_final_positions !== undefined || goals.position !== undefined)){
        if (topic){
            topic = false;
            information += "&lt;br>&lt;br>&lt;b>" + RUR.translate("Goal to achieve:") + "&lt;/b>";
        }
        if (goals.possible_final_positions !== undefined &amp;&amp; goals.possible_final_positions.length > 2) {
            information += "&lt;br>" + RUR.translate("The final required position of the robot will be chosen at random.");
        } else {
            information += "&lt;br>" + RUR.translate("The final position of the robot must be (x, y) = ") +
                           "(" + goals.position.x + ", " + goals.position.y + ")";
        }
    }

    $("#World-info").html(information);
    $('.world_info_source').each(function() {
        var $this = $(this), $code = $this.text();
        $this.empty();
        var myCodeMirror = CodeMirror(this, {
            value: $code,
            mode:  RUR.state.programming_language,
            lineNumbers: !$this.is('.inline'),
            readOnly: true,
            theme: 'reeborg-readonly'
        });
    });
    $('.world_info_onload').each(function() {
        var $this = $(this), $code = $this.text();
        $this.empty();
        var myCodeMirror = CodeMirror(this, {
            value: $code,
            mode:  RUR.state.onload_programming_language,
            lineNumbers: !$this.is('.inline'),
            readOnly: true,
            theme: 'reeborg-readonly'
        });
    });
};

RUR.create_and_activate_dialogs( $("#world-info-button"), $("#World-info"),
                                 {height:600, width:800}, RUR.world_get.world_info);</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>



<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on Monday, August 7th 2017
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->




</body>
</html>
